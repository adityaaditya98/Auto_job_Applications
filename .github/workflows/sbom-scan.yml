name: SBOM Scan

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

jobs:
  scan:
    runs-on: ubuntu-latest
    # Restrict to specific branches for extra security
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tags
      
      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0
      
      - name: Extract version
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            # If scanning a git tag, use the tag name (highest priority)
            VERSION="${{ github.ref_name }}"
            GIT_TAG="${{ github.ref_name }}"
            echo "‚úÖ Using version from git tag: $VERSION"
          elif [ -f "package.json" ]; then
            # Try to read version from package.json
            if command -v jq &> /dev/null; then
              VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "")
            else
              # Fallback: use grep/sed if jq is not available
              VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "")
            fi
            
            # Validate version was found and is not null/empty
            if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
              echo "‚ö†Ô∏è Warning: No version found in package.json, using commit-based version"
              VERSION="main-$(git rev-parse --short HEAD)"
            else
              echo "‚úÖ Using version from package.json: $VERSION"
            fi
            GIT_TAG=""
          else
            # Fallback: use commit-based version
            VERSION="main-$(git rev-parse --short HEAD)"
            GIT_TAG=""
            echo "‚ÑπÔ∏è No package.json found, using commit-based version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
          echo "git_commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js (if package.json exists)
        if: hashFiles('**/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install npm dependencies (if package.json exists)
        if: hashFiles('**/package.json') != ''
        run: |
          # Find all package.json files and install dependencies
          # We need package-lock.json for syft to detect packages
          find . -name "package.json" -not -path "*/node_modules/*" -print0 | while IFS= read -r -d '' pkg; do
            PKG_DIR=$(dirname "$pkg")
            (cd "$PKG_DIR" && npm install --no-audit --no-fund) || {
              echo "‚ö†Ô∏è Warning: npm install failed in $PKG_DIR"
            }
          done
      
      - name: Setup Python (if requirements.txt exists)
        if: hashFiles('**/requirements.txt') != ''
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Generate SBOM
        id: sbom
        run: |
          # Create .syftignore file to exclude non-package directories
          cat > .syftignore << EOF
          .github/
          .git/
          .next/
          out/
          dist/
          build/
          node_modules/
          __pycache__/
          *.pyc
          .venv/
          venv/
          .env*
          *.log
          coverage/
          EOF
          
          # Scan only package manifests to reduce SBOM size
          syft scan dir:. --scope squashed -o cyclonedx-json > sbom.json 2>syft-warnings.log || {
            echo "‚ùå Syft scan failed"
            cat syft-warnings.log || true
            exit 1
          }
          
          # Reduce SBOM size by keeping only essential fields
          jq 'del(.components[].properties, .components[].hashes) | del(.vulnerabilities, .externalReferences)' sbom.json > sbom.min.json
          mv sbom.min.json sbom.json
          
          # Validate JSON is valid
          if [ ! -s sbom.json ] || ! jq empty sbom.json 2>/dev/null; then
            echo "‚ùå Error: Generated SBOM is not valid JSON"
            if [ -s syft-warnings.log ]; then
              cat syft-warnings.log
            fi
            exit 1
          fi
      
      - name: Upload SBOM to Backend
        env:
          # Secrets are automatically masked in logs
          API_TOKEN: ${{ secrets.OSS_API_TOKEN }}
          API_URL: ${{ secrets.OSS_API_URL }}
        run: |
          # Validate API_URL is set and properly formatted
          if [ -z "$API_URL" ]; then
            echo "‚ùå Error: OSS_API_URL secret is not set"
            exit 1
          fi
          
          # Remove trailing slash if present
          API_URL=$(echo "$API_URL" | sed 's:/*$::')
          
          # Validate URL format (must start with http:// or https://)
          if [[ ! "$API_URL" =~ ^https?:// ]]; then
            echo "‚ùå Error: OSS_API_URL must start with http:// or https://"
            echo "Current value: $API_URL"
            exit 1
          fi
          
          # Validate API_TOKEN is set
          if [ -z "$API_TOKEN" ]; then
            echo "‚ùå Error: OSS_API_TOKEN secret is not set"
            exit 1
          fi
          
          echo "‚úÖ API URL: ${API_URL}"
          echo "‚úÖ API Token: ${API_TOKEN:0:10}... (masked)"
          echo "‚úÖ Repository: ${{ github.repository }}"
          echo "‚úÖ Version: ${{ steps.version.outputs.version }}"
          
          # Create payload file using jq to properly handle JSON formatting
          jq -n \
            --arg repo "${{ github.repository }}" \
            --arg version "${{ steps.version.outputs.version }}" \
            --arg git_tag "${{ steps.version.outputs.git_tag }}" \
            --arg git_commit_sha "${{ steps.version.outputs.git_commit_sha }}" \
            --slurpfile sbom sbom.json \
            '{repository_name: $repo, version: $version, git_tag: $git_tag, git_commit_sha: $git_commit_sha, sbom_data: $sbom[0]}' > payload.json
          
          # GitHub automatically masks the token if it appears in output
          # Add retry logic with exponential backoff for transient failures
          MAX_ATTEMPTS=3
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üì§ Attempt $ATTEMPT/$MAX_ATTEMPTS - Uploading SBOM to backend..."
            
            HTTP_CODE=$(curl -X POST "${API_URL}/scans/trigger" \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Content-Type: application/json" \
              --max-time 60 \
              --connect-timeout 10 \
              -w "%{http_code}" \
              -o response.json \
              -d @payload.json 2>&1)
            
            if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "201" ]; then
              echo "‚úÖ SBOM uploaded successfully! (HTTP $HTTP_CODE)"
              cat response.json
              exit 0
            elif [ "$HTTP_CODE" == "504" ] || [ "$HTTP_CODE" == "503" ]; then
              echo "‚ö†Ô∏è Backend temporarily unavailable (HTTP $HTTP_CODE)"
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                WAIT_TIME=$((30 * ATTEMPT))
                echo "‚è≥ Waiting ${WAIT_TIME}s before retry..."
                sleep $WAIT_TIME
              fi
            else
              echo "‚ùå Failed to upload SBOM (HTTP $HTTP_CODE)"
              cat response.json
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          echo "‚ùå Failed to upload SBOM to backend after $MAX_ATTEMPTS attempts"
          exit 1
